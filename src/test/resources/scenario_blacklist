Feature "AggregationAcceptance": Scenario "Aggregate on list values"
Feature "AggregationAcceptance": Scenario "Aggregate on property"
Feature "AggregationAcceptance": Scenario "Aggregates in aggregates"
Feature "AggregationAcceptance": Scenario "Aggregates inside normal functions"
Feature "AggregationAcceptance": Scenario "Aggregates ordered by arithmetics"
Feature "AggregationAcceptance": Scenario "Aggregates with arithmetics"
Feature "AggregationAcceptance": Scenario "Aggregation of named paths"
Feature "AggregationAcceptance": Scenario "Aggregation with `min()`"
Feature "AggregationAcceptance": Scenario "Collect distinct nulls"
Feature "AggregationAcceptance": Scenario "Collect distinct values mixed with nulls"
Feature "AggregationAcceptance": Scenario "Count nodes"
Feature "AggregationAcceptance": Scenario "Count non-null values"
Feature "AggregationAcceptance": Scenario "Counting with loops"
Feature "AggregationAcceptance": Scenario "Distinct on null"
Feature "AggregationAcceptance": Scenario "Distinct on unbound node"
Feature "AggregationAcceptance": Scenario "Handle aggregates inside non-aggregate expressions"
Feature "AggregationAcceptance": Scenario "Handle aggregation on functions"
Feature "AggregationAcceptance": Scenario "Handle subexpression in aggregation also occurring as standalone expression with nested aggregation in a literal map"
Feature "AggregationAcceptance": Scenario "Multiple aggregates on same variable"
Feature "AggregationAcceptance": Scenario "No overflow during summation"
Feature "AggregationAcceptance": Scenario "Projection during aggregation in WITH before MERGE and after WITH with predicate"
Feature "AggregationAcceptance": Scenario "Simple counting of nodes"
Feature "AggregationAcceptance": Scenario "Sort on aggregate function and normal property"
Feature "AggregationAcceptance": Scenario "Sum non-null values"
Feature "AggregationAcceptance": Scenario "Support column renaming for aggregates as well"
Feature "AggregationAcceptance": Scenario "Support multiple divisions in aggregate function"
Feature "AggregationAcceptance": Scenario "`max()` should aggregate strings"
Feature "AggregationAcceptance": Scenario "`min()` should aggregate strings"
Feature "ColumnNameAcceptance": Scenario "Keeping used expression 1"
Feature "ColumnNameAcceptance": Scenario "Keeping used expression 2"
Feature "ColumnNameAcceptance": Scenario "Keeping used expression 3"
Feature "ColumnNameAcceptance": Scenario "Keeping used expression 4"
Feature "Comparability": Scenario "Comparing across types yields null, except numbers #1"
Feature "Comparability": Scenario "Comparing across types yields null, except numbers #2"
Feature "Comparability": Scenario "Comparing across types yields null, except numbers #3"
Feature "Comparability": Scenario "Comparing across types yields null, except numbers #4"
Feature "Comparability": Scenario "Comparing strings and integers using > in a OR'd predicate"
Feature "Comparability": Scenario "Comparing strings and integers using > in an AND'd predicate"
Feature "ComparisonOperatorAcceptance": Scenario "Handling long chains of operators"
Feature "ComparisonOperatorAcceptance": Scenario "Handling numerical ranges 1"
Feature "ComparisonOperatorAcceptance": Scenario "Handling numerical ranges 2"
Feature "ComparisonOperatorAcceptance": Scenario "Handling numerical ranges 3"
Feature "ComparisonOperatorAcceptance": Scenario "Handling numerical ranges 4"
Feature "ComparisonOperatorAcceptance": Scenario "Handling string ranges 1"
Feature "ComparisonOperatorAcceptance": Scenario "Handling string ranges 2"
Feature "ComparisonOperatorAcceptance": Scenario "Handling string ranges 3"
Feature "ComparisonOperatorAcceptance": Scenario "Handling string ranges 4"
Feature "Create": Scenario "Creating a node with a label"
Feature "Create": Scenario "Creating a node with a property"
Feature "Create": Scenario "Creating a node"
Feature "Create": Scenario "Creating two nodes and a relationship"
Feature "Create": Scenario "Creating two nodes"
Feature "CreateAcceptance": Scenario "A bound node should be recognized after projection with WITH + MERGE node"
Feature "CreateAcceptance": Scenario "A bound node should be recognized after projection with WITH + MERGE pattern"
Feature "CreateAcceptance": Scenario "A bound node should be recognized after projection with WITH + UNWIND"
Feature "CreateAcceptance": Scenario "A bound node should be recognized after projection with WITH + WITH"
Feature "CreateAcceptance": Scenario "Combine MATCH and CREATE"
Feature "CreateAcceptance": Scenario "Combine MATCH, WITH and CREATE"
Feature "CreateAcceptance": Scenario "Create a pattern with multiple hops in the reverse direction"
Feature "CreateAcceptance": Scenario "Create a pattern with multiple hops in varying directions"
Feature "CreateAcceptance": Scenario "Create a pattern with multiple hops with multiple types and varying directions"
Feature "CreateAcceptance": Scenario "Create a pattern with multiple hops"
Feature "CreateAcceptance": Scenario "Create a relationship and an end node from a matched starting node"
Feature "CreateAcceptance": Scenario "Create a relationship with a property"
Feature "CreateAcceptance": Scenario "Create a relationship with a reversed direction"
Feature "CreateAcceptance": Scenario "Create a relationship with the correct direction"
Feature "CreateAcceptance": Scenario "Create a self loop using MATCH"
Feature "CreateAcceptance": Scenario "Create a self loop"
Feature "CreateAcceptance": Scenario "Create a simple pattern"
Feature "CreateAcceptance": Scenario "Create a single node after a WITH"
Feature "CreateAcceptance": Scenario "Create a single node with multiple labels"
Feature "CreateAcceptance": Scenario "Create a single node with properties"
Feature "CreateAcceptance": Scenario "Create nodes and relationships"
Feature "CreateAcceptance": Scenario "Creating a node with null properties should not return those properties"
Feature "CreateAcceptance": Scenario "Creating a pattern with multiple hops and changing directions"
Feature "CreateAcceptance": Scenario "Creating a relationship with null properties should not return those properties"
Feature "CreateAcceptance": Scenario "Fail when trying to create using an undirected relationship pattern"
Feature "CreateAcceptance": Scenario "Newly-created nodes not visible to preceding MATCH"
Feature "CreateAcceptance": Scenario "Nodes are not created when aliases are applied to variable names multiple times"
Feature "CreateAcceptance": Scenario "Nodes are not created when aliases are applied to variable names"
Feature "CreateAcceptance": Scenario "Only a single node is created when an alias is applied to a variable name multiple times"
Feature "CreateAcceptance": Scenario "Only a single node is created when an alias is applied to a variable name"
Feature "DeleteAcceptance": Scenario "Create and delete in same query"
Feature "DeleteAcceptance": Scenario "Delete node from a list"
Feature "DeleteAcceptance": Scenario "Delete nodes from a map"
Feature "DeleteAcceptance": Scenario "Delete nodes"
Feature "DeleteAcceptance": Scenario "Delete on null node"
Feature "DeleteAcceptance": Scenario "Delete on null path"
Feature "DeleteAcceptance": Scenario "Delete optionally matched relationship"
Feature "DeleteAcceptance": Scenario "Delete paths from nested map/list"
Feature "DeleteAcceptance": Scenario "Delete relationship from a list"
Feature "DeleteAcceptance": Scenario "Delete relationship with bidirectional matching"
Feature "DeleteAcceptance": Scenario "Delete relationships from a map"
Feature "DeleteAcceptance": Scenario "Delete relationships from nested map/list"
Feature "DeleteAcceptance": Scenario "Delete relationships"
Feature "DeleteAcceptance": Scenario "Deleting connected nodes"
Feature "DeleteAcceptance": Scenario "Detach delete node"
Feature "DeleteAcceptance": Scenario "Detach delete nodes from nested map/list"
Feature "DeleteAcceptance": Scenario "Detach delete on null node"
Feature "DeleteAcceptance": Scenario "Detach deleting connected nodes and relationships"
Feature "DeleteAcceptance": Scenario "Detach deleting paths"
Feature "DeleteAcceptance": Scenario "Undirected expand followed by delete and count"
Feature "DeleteAcceptance": Scenario "Undirected variable length expand followed by delete and count"
Feature "EqualsAcceptance": Scenario "Any-typed string comparison"
Feature "EqualsAcceptance": Scenario "Comparing nodes to nodes"
Feature "EqualsAcceptance": Scenario "Comparing relationships to relationships"
Feature "EqualsAcceptance": Scenario "Number-typed float comparison"
Feature "EqualsAcceptance": Scenario "Number-typed integer comparison"
Feature "ExpressionAcceptance": Scenario "Execute n['name'] in read queries"
Feature "ExpressionAcceptance": Scenario "Execute n['name'] in update queries"
Feature "ExpressionAcceptance": Scenario "Execute n[0]"
Feature "ExpressionAcceptance": Scenario "Fail at compile time when attempting to index with a non-integer into a list"
Feature "ExpressionAcceptance": Scenario "Fail at runtime when attempting to index with a String into a Collection"
Feature "ExpressionAcceptance": Scenario "Fail at runtime when attempting to index with an Int into a Map"
Feature "ExpressionAcceptance": Scenario "Fail at runtime when trying to index into a list with a list"
Feature "ExpressionAcceptance": Scenario "Fail at runtime when trying to index into a map with a non-string"
Feature "ExpressionAcceptance": Scenario "Fail at runtime when trying to index something which is not a map or collection"
Feature "ExpressionAcceptance": Scenario "IN should work with list slices"
Feature "ExpressionAcceptance": Scenario "IN should work with literal list slices"
Feature "ExpressionAcceptance": Scenario "IN should work with nested list subscripting"
Feature "ExpressionAcceptance": Scenario "IN should work with nested literal list subscripting"
Feature "ExpressionAcceptance": Scenario "Use collection lookup based on parameters when there is lhs type information"
Feature "ExpressionAcceptance": Scenario "Use collection lookup based on parameters when there is no type information"
Feature "ExpressionAcceptance": Scenario "Use collection lookup based on parameters when there is rhs type information"
Feature "ExpressionAcceptance": Scenario "Use dynamic property lookup based on parameters when there is lhs type information"
Feature "ExpressionAcceptance": Scenario "Use dynamic property lookup based on parameters when there is no type information"
Feature "ExpressionAcceptance": Scenario "Use dynamic property lookup based on parameters when there is rhs type information"
Feature "FunctionsAcceptance": Scenario "Functions should return null if they get path containing unbound"
Feature "FunctionsAcceptance": Scenario "IS NOT NULL with literal maps #1"
Feature "FunctionsAcceptance": Scenario "IS NOT NULL with literal maps #2"
Feature "FunctionsAcceptance": Scenario "IS NOT NULL with literal maps #3"
Feature "FunctionsAcceptance": Scenario "Run coalesce"
Feature "FunctionsAcceptance": Scenario "`exists()` is case insensitive"
Feature "FunctionsAcceptance": Scenario "`exists()` with dynamic property lookup"
Feature "FunctionsAcceptance": Scenario "`exists()` with literal maps #1"
Feature "FunctionsAcceptance": Scenario "`exists()` with literal maps #2"
Feature "FunctionsAcceptance": Scenario "`exists()` with literal maps #3"
Feature "FunctionsAcceptance": Scenario "`labels()` failing on a path"
Feature "FunctionsAcceptance": Scenario "`labels()` should accept type Any"
Feature "FunctionsAcceptance": Scenario "`percentileCont()` failing on bad arguments #1"
Feature "FunctionsAcceptance": Scenario "`percentileCont()` failing on bad arguments #2"
Feature "FunctionsAcceptance": Scenario "`percentileCont()` failing on bad arguments #3"
Feature "FunctionsAcceptance": Scenario "`percentileCont()` #1"
Feature "FunctionsAcceptance": Scenario "`percentileCont()` #2"
Feature "FunctionsAcceptance": Scenario "`percentileCont()` #3"
Feature "FunctionsAcceptance": Scenario "`percentileDisc()` failing in more involved query"
Feature "FunctionsAcceptance": Scenario "`percentileDisc()` failing on bad arguments #1"
Feature "FunctionsAcceptance": Scenario "`percentileDisc()` failing on bad arguments #2"
Feature "FunctionsAcceptance": Scenario "`percentileDisc()` failing on bad arguments #3"
Feature "FunctionsAcceptance": Scenario "`percentileDisc()` #1"
Feature "FunctionsAcceptance": Scenario "`percentileDisc()` #2"
Feature "FunctionsAcceptance": Scenario "`percentileDisc()` #3"
Feature "FunctionsAcceptance": Scenario "`properties()` failing on a list of booleans"
Feature "FunctionsAcceptance": Scenario "`properties()` failing on a string literal"
Feature "FunctionsAcceptance": Scenario "`properties()` failing on an integer literal"
Feature "FunctionsAcceptance": Scenario "`properties()` on a map"
Feature "FunctionsAcceptance": Scenario "`properties()` on a node"
Feature "FunctionsAcceptance": Scenario "`properties()` on a relationship"
Feature "FunctionsAcceptance": Scenario "`properties()` on null"
Feature "FunctionsAcceptance": Scenario "`reverse()`"
Feature "FunctionsAcceptance": Scenario "`split()`"
Feature "FunctionsAcceptance": Scenario "`type()` handling Any type"
Feature "FunctionsAcceptance": Scenario "`type()` on mixed null and non-null relationships"
Feature "FunctionsAcceptance": Scenario "`type()` on null relationship"
Feature "FunctionsAcceptance": Scenario "`type()` on two relationships"
Feature "FunctionsAcceptance": Scenario "`type()`"
Feature "KeysAcceptance": Scenario "Using `keys()` on a literal map"
Feature "KeysAcceptance": Scenario "Using `keys()` on a parameter map"
Feature "KeysAcceptance": Scenario "Using `keys()` on a relationship, empty result"
Feature "KeysAcceptance": Scenario "Using `keys()` on a relationship, non-empty result"
Feature "KeysAcceptance": Scenario "Using `keys()` on a single node, empty result"
Feature "KeysAcceptance": Scenario "Using `keys()` on a single node, non-empty result"
Feature "KeysAcceptance": Scenario "Using `keys()` on an optionally matched node"
Feature "KeysAcceptance": Scenario "Using `keys()` on an optionally matched relationship"
Feature "KeysAcceptance": Scenario "Using `keys()` on multiple nodes, non-empty result"
Feature "LabelsAcceptance": Scenario "Adding a single label"
Feature "LabelsAcceptance": Scenario "Adding multiple labels"
Feature "LabelsAcceptance": Scenario "Create node with label in pattern"
Feature "LabelsAcceptance": Scenario "Creating node with two labels"
Feature "LabelsAcceptance": Scenario "Creating node without label"
Feature "LabelsAcceptance": Scenario "Fail when adding a new label predicate on a node that is already bound 1"
Feature "LabelsAcceptance": Scenario "Fail when adding new label predicate on a node that is already bound 2"
Feature "LabelsAcceptance": Scenario "Fail when adding new label predicate on a node that is already bound 3"
Feature "LabelsAcceptance": Scenario "Fail when adding new label predicate on a node that is already bound 4"
Feature "LabelsAcceptance": Scenario "Fail when adding new label predicate on a node that is already bound 5"
Feature "LabelsAcceptance": Scenario "Ignore space before colon"
Feature "LabelsAcceptance": Scenario "Ignore space when creating node with labels"
Feature "LabelsAcceptance": Scenario "Ignoring intermediate whitespace 1"
Feature "LabelsAcceptance": Scenario "Ignoring intermediate whitespace 2"
Feature "LabelsAcceptance": Scenario "Removing a label"
Feature "LabelsAcceptance": Scenario "Removing a non-existent label"
Feature "LabelsAcceptance": Scenario "Using `labels()` in return clauses"
Feature "LargeCreateQuery": Scenario "Generate the movie graph correctly"
Feature "LargeCreateQuery": Scenario "Many CREATE clauses"
Feature "ListComprehension": Scenario "Returning a list comprehension"
Feature "ListComprehension": Scenario "Using a list comprehension in a WHERE"
Feature "ListComprehension": Scenario "Using a list comprehension in a WITH"
Feature "Literals": Scenario "Return a boolean"
Feature "Literals": Scenario "Return a double-quoted string"
Feature "Literals": Scenario "Return a float in exponent form"
Feature "Literals": Scenario "Return a float"
Feature "Literals": Scenario "Return a nonempty list"
Feature "Literals": Scenario "Return a nonempty map"
Feature "Literals": Scenario "Return a single-quoted string"
Feature "Literals": Scenario "Return an empty list"
Feature "Literals": Scenario "Return an empty map"
Feature "Literals": Scenario "Return an integer"
Feature "Literals": Scenario "Return null"
Feature "MatchAcceptance": Scenario "Accept skip zero"
Feature "MatchAcceptance": Scenario "Cope with shadowed variables"
Feature "MatchAcceptance": Scenario "Do not return anything because path length does not match"
Feature "MatchAcceptance": Scenario "Filter out based on node prop name"
Feature "MatchAcceptance": Scenario "Honour the column name for RETURN items"
Feature "MatchAcceptance": Scenario "Longer path query should return results in written order"
Feature "MatchAcceptance": Scenario "Pass the path length test"
Feature "MatchAcceptance": Scenario "Path query should return results in written order"
Feature "MatchAcceptance": Scenario "Rel type function works as expected"
Feature "MatchAcceptance": Scenario "Return a named var length path of length zero"
Feature "MatchAcceptance": Scenario "Return a simple path"
Feature "MatchAcceptance": Scenario "Return a three node path"
Feature "MatchAcceptance": Scenario "Return a var length path of length zero"
Feature "MatchAcceptance": Scenario "Return a var length path"
Feature "MatchAcceptance": Scenario "Return relationships by collecting them as a list - undirected"
Feature "MatchAcceptance": Scenario "Return relationships by collecting them as a list - wrong way"
Feature "MatchAcceptance": Scenario "Return relationships by collecting them as a list"
Feature "MatchAcceptance": Scenario "Return relationships by fetching them from the path - starting from the end"
Feature "MatchAcceptance": Scenario "Return relationships by fetching them from the path"
Feature "MatchAcceptance": Scenario "Return two subgraphs with bound undirected relationship and optional relationship"
Feature "MatchAcceptance": Scenario "Return two subgraphs with bound undirected relationship"
Feature "MatchAcceptance": Scenario "Use multiple MATCH clauses to do a Cartesian product"
Feature "MatchAcceptance": Scenario "Walk alternative relationships"
Feature "MatchAcceptance2": Scenario "Adding a property and a literal in projection"
Feature "MatchAcceptance2": Scenario "Adding list properties in projection"
Feature "MatchAcceptance2": Scenario "Aggregation with named paths"
Feature "MatchAcceptance2": Scenario "Comparing nodes for equality"
Feature "MatchAcceptance2": Scenario "Counting an empty graph"
Feature "MatchAcceptance2": Scenario "Counting rows after MATCH, MERGE, OPTIONAL MATCH"
Feature "MatchAcceptance2": Scenario "Do not fail when evaluating predicates with illegal operations if the OR'd predicate evaluates to true"
Feature "MatchAcceptance2": Scenario "Do not fail when predicates on optionally matched and missed nodes are invalid"
Feature "MatchAcceptance2": Scenario "Excluding connected nodes"
Feature "MatchAcceptance2": Scenario "Fail when using property access on primitive type"
Feature "MatchAcceptance2": Scenario "Handling cyclic patterns when separated into two parts"
Feature "MatchAcceptance2": Scenario "Handling cyclic patterns"
Feature "MatchAcceptance2": Scenario "Handling direction of named paths"
Feature "MatchAcceptance2": Scenario "Handling fixed-length variable length pattern"
Feature "MatchAcceptance2": Scenario "MATCH and OPTIONAL MATCH on same pattern"
Feature "MatchAcceptance2": Scenario "MATCH with OPTIONAL MATCH in longer pattern"
Feature "MatchAcceptance2": Scenario "Matching a self-loop"
Feature "MatchAcceptance2": Scenario "Matching and optionally matching with bound nodes in reverse direction"
Feature "MatchAcceptance2": Scenario "Matching and optionally matching with unbound nodes and equality predicate in reverse direction"
Feature "MatchAcceptance2": Scenario "Matching and returning ordered results, with LIMIT"
Feature "MatchAcceptance2": Scenario "Matching disconnected patterns"
Feature "MatchAcceptance2": Scenario "Matching from null nodes should return no results owing to finding no matches"
Feature "MatchAcceptance2": Scenario "Matching from null nodes should return no results owing to matches being filtered out"
Feature "MatchAcceptance2": Scenario "Matching longer variable length paths"
Feature "MatchAcceptance2": Scenario "Matching path with both directions should respect other directions"
Feature "MatchAcceptance2": Scenario "Matching path with multiple bidirectional relationships"
Feature "MatchAcceptance2": Scenario "Matching relationships into a list and matching variable length using the list"
Feature "MatchAcceptance2": Scenario "Matching relationships into a list and matching variable length using the list, with bound nodes"
Feature "MatchAcceptance2": Scenario "Matching relationships into a list and matching variable length using the list, with bound nodes, wrong direction"
Feature "MatchAcceptance2": Scenario "Matching twice with conflicting relationship types on same relationship"
Feature "MatchAcceptance2": Scenario "Matching twice with duplicate relationship types on same relationship"
Feature "MatchAcceptance2": Scenario "Matching using a relationship that is already bound"
Feature "MatchAcceptance2": Scenario "Matching using a relationship that is already bound, in conjunction with aggregation and ORDER BY"
Feature "MatchAcceptance2": Scenario "Matching using a relationship that is already bound, in conjunction with aggregation"
Feature "MatchAcceptance2": Scenario "Matching using an undirected pattern"
Feature "MatchAcceptance2": Scenario "Matching using self-referencing pattern returns no result"
Feature "MatchAcceptance2": Scenario "Matching variable length pattern with property predicate"
Feature "MatchAcceptance2": Scenario "Matching variable length patterns from a bound node"
Feature "MatchAcceptance2": Scenario "Matching with LIMIT and optionally matching using a relationship and node that are both already bound"
Feature "MatchAcceptance2": Scenario "Matching with LIMIT and optionally matching using a relationship that is already bound"
Feature "MatchAcceptance2": Scenario "Matching with LIMIT and predicates, then matching again using a relationship and node that are both already bound along with a duplicate predicate"
Feature "MatchAcceptance2": Scenario "Matching with LIMIT, then matching again using a relationship and node that are both already bound along with an additional predicate"
Feature "MatchAcceptance2": Scenario "Matching with aggregation"
Feature "MatchAcceptance2": Scenario "Named path with WITH"
Feature "MatchAcceptance2": Scenario "Named path with alternating directed/undirected relationships"
Feature "MatchAcceptance2": Scenario "Named path with multiple alternating directed/undirected relationships"
Feature "MatchAcceptance2": Scenario "Named path with undirected fixed variable length pattern"
Feature "MatchAcceptance2": Scenario "Non-optional matches should not return nulls"
Feature "MatchAcceptance2": Scenario "OPTIONAL MATCH returns null"
Feature "MatchAcceptance2": Scenario "OPTIONAL MATCH with previously bound nodes"
Feature "MatchAcceptance2": Scenario "ORDER BY with LIMIT"
Feature "MatchAcceptance2": Scenario "Optionally matching from null nodes should return null"
Feature "MatchAcceptance2": Scenario "Optionally matching named paths with single and variable length patterns"
Feature "MatchAcceptance2": Scenario "Optionally matching named paths with variable length patterns"
Feature "MatchAcceptance2": Scenario "Optionally matching named paths"
Feature "MatchAcceptance2": Scenario "Projecting a list of nodes and relationships"
Feature "MatchAcceptance2": Scenario "Projecting a map of nodes and relationships"
Feature "MatchAcceptance2": Scenario "Respecting direction when matching existing path"
Feature "MatchAcceptance2": Scenario "Respecting direction when matching non-existent path with multiple directions"
Feature "MatchAcceptance2": Scenario "Respecting direction when matching non-existent path"
Feature "MatchAcceptance2": Scenario "Returning bound nodes that are not part of the pattern"
Feature "MatchAcceptance2": Scenario "Returning label predicate expression"
Feature "MatchAcceptance2": Scenario "Simple OPTIONAL MATCH on empty graph"
Feature "MatchAcceptance2": Scenario "Simple variable length pattern"
Feature "MatchAcceptance2": Scenario "Three bound nodes pointing to the same node with extra connections"
Feature "MatchAcceptance2": Scenario "Three bound nodes pointing to the same node"
Feature "MatchAcceptance2": Scenario "Two bound nodes pointing to the same node"
Feature "MatchAcceptance2": Scenario "Undirected named path"
Feature "MatchAcceptance2": Scenario "Variable length pattern checking labels on endnodes"
Feature "MatchAcceptance2": Scenario "Variable length pattern with label predicate on both sides"
Feature "MatchAcceptance2": Scenario "Variable length patterns and nulls"
Feature "MatchAcceptance2": Scenario "Variable length relationship in OPTIONAL MATCH"
Feature "MatchAcceptance2": Scenario "Variable length relationship variables are lists of relationships"
Feature "MatchAcceptance2": Scenario "Variable length relationship without bounds"
Feature "MatchAcceptance2": Scenario "Variable length relationship without lower bound"
Feature "MatchAcceptance2": Scenario "Variable-length named path"
Feature "MatchAcceptance2": Scenario "Zero-length named path"
Feature "MatchAcceptance2": Scenario "Zero-length variable length pattern in the middle of the pattern"
Feature "MatchAcceptance2": Scenario "`collect()` filtering nulls"
Feature "MatchingSelfRelationships": Scenario "Counting directed self-relationships"
Feature "MatchingSelfRelationships": Scenario "Counting distinct undirected self-relationships in self-relationship graph"
Feature "MatchingSelfRelationships": Scenario "Counting undirected self-relationships in self-relationship graph"
Feature "MatchingSelfRelationships": Scenario "Directed match of a simple relationship, count"
Feature "MatchingSelfRelationships": Scenario "Directed match of self-relationship on self-relationship graph"
Feature "MatchingSelfRelationships": Scenario "Directed match of self-relationship on self-relationship graph, count"
Feature "MatchingSelfRelationships": Scenario "Directed match on self-relationship graph, count"
Feature "MatchingSelfRelationships": Scenario "Mixing directed and undirected pattern parts with self-relationship, count"
Feature "MatchingSelfRelationships": Scenario "Mixing directed and undirected pattern parts with self-relationship, simple"
Feature "MatchingSelfRelationships": Scenario "Mixing directed and undirected pattern parts with self-relationship, undirected count"
Feature "MatchingSelfRelationships": Scenario "Mixing directed and undirected pattern parts with self-relationship, undirected"
Feature "MatchingSelfRelationships": Scenario "Undirected match in self-relationship graph"
Feature "MatchingSelfRelationships": Scenario "Undirected match in self-relationship graph, count"
Feature "MatchingSelfRelationships": Scenario "Undirected match of self-relationship in self-relationship graph"
Feature "MatchingSelfRelationships": Scenario "Undirected match of self-relationship in self-relationship graph, count"
Feature "MatchingSelfRelationships": Scenario "Undirected match on simple relationship graph"
Feature "MatchingSelfRelationships": Scenario "Undirected match on simple relationship graph, count"
Feature "MergeIntoAcceptance": Scenario "Copying properties from literal map with ON CREATE"
Feature "MergeIntoAcceptance": Scenario "Copying properties from literal map with ON MATCH"
Feature "MergeIntoAcceptance": Scenario "Copying properties from node with ON CREATE"
Feature "MergeIntoAcceptance": Scenario "Copying properties from node with ON MATCH"
Feature "MergeIntoAcceptance": Scenario "Null-setting one property with ON CREATE"
Feature "MergeIntoAcceptance": Scenario "Updating one property with ON CREATE"
Feature "MergeNodeAcceptance": Scenario "Merge followed by multiple creates"
Feature "MergeNodeAcceptance": Scenario "Merge must properly handle multiple labels"
Feature "MergeNodeAcceptance": Scenario "Merge node and set property on match"
Feature "MergeNodeAcceptance": Scenario "Merge node should create when it doesn't match, properties and label"
Feature "MergeNodeAcceptance": Scenario "Merge node should create when it doesn't match, properties"
Feature "MergeNodeAcceptance": Scenario "Merge node when no nodes exist"
Feature "MergeNodeAcceptance": Scenario "Merge node with label add label on create"
Feature "MergeNodeAcceptance": Scenario "Merge node with label add label on match when it exists"
Feature "MergeNodeAcceptance": Scenario "Merge node with label add property on create"
Feature "MergeNodeAcceptance": Scenario "Merge node with label add property on update when it exists"
Feature "MergeNodeAcceptance": Scenario "Merge node with label when it exists"
Feature "MergeNodeAcceptance": Scenario "Merge node with label"
Feature "MergeNodeAcceptance": Scenario "Merge node with prop and label"
Feature "MergeNodeAcceptance": Scenario "Merges should not be able to match on deleted nodes"
Feature "MergeNodeAcceptance": Scenario "ON CREATE on created nodes"
Feature "MergeNodeAcceptance": Scenario "Should be able to merge using property from match"
Feature "MergeNodeAcceptance": Scenario "Should be able to set labels on match and on create"
Feature "MergeNodeAcceptance": Scenario "Should be able to set labels on match"
Feature "MergeNodeAcceptance": Scenario "Should be able to use properties from match in ON CREATE"
Feature "MergeNodeAcceptance": Scenario "Should be able to use properties from match in ON MATCH and ON CREATE"
Feature "MergeNodeAcceptance": Scenario "Should be able to use properties from match in ON MATCH"
Feature "MergeNodeAcceptance": Scenario "Should handle argument properly"
Feature "MergeNodeAcceptance": Scenario "Should handle arguments properly with only write clauses"
Feature "MergeNodeAcceptance": Scenario "Should support updates while merging"
Feature "MergeNodeAcceptance": Scenario "Should work when finding multiple elements"
Feature "MergeNodeAcceptance": Scenario "Unwind combined with merge"
Feature "MergeRelationshipAcceptance": Scenario "Aliasing of existing nodes 1"
Feature "MergeRelationshipAcceptance": Scenario "Aliasing of existing nodes 2"
Feature "MergeRelationshipAcceptance": Scenario "Creating a relationship"
Feature "MergeRelationshipAcceptance": Scenario "Creating relationship using merged nodes"
Feature "MergeRelationshipAcceptance": Scenario "Creating relationship when all matches filtered out"
Feature "MergeRelationshipAcceptance": Scenario "Creating relationship with property"
Feature "MergeRelationshipAcceptance": Scenario "Do not match on deleted entities"
Feature "MergeRelationshipAcceptance": Scenario "Do not match on deleted relationships"
Feature "MergeRelationshipAcceptance": Scenario "Double aliasing of existing nodes 1"
Feature "MergeRelationshipAcceptance": Scenario "Double aliasing of existing nodes 2"
Feature "MergeRelationshipAcceptance": Scenario "Fail when imposing new predicates on a variable that is already bound"
Feature "MergeRelationshipAcceptance": Scenario "Filtering relationships"
Feature "MergeRelationshipAcceptance": Scenario "Introduce named paths 1"
Feature "MergeRelationshipAcceptance": Scenario "Introduce named paths 2"
Feature "MergeRelationshipAcceptance": Scenario "Match both incoming and outgoing relationships when direction unspecified"
Feature "MergeRelationshipAcceptance": Scenario "Match outgoing relationship when direction unspecified"
Feature "MergeRelationshipAcceptance": Scenario "Matching a relationship"
Feature "MergeRelationshipAcceptance": Scenario "Matching incoming relationship"
Feature "MergeRelationshipAcceptance": Scenario "Matching two relationships"
Feature "MergeRelationshipAcceptance": Scenario "Matching using list property"
Feature "MergeRelationshipAcceptance": Scenario "Mixing MERGE with CREATE"
Feature "MergeRelationshipAcceptance": Scenario "UNWIND with multiple merges"
Feature "MergeRelationshipAcceptance": Scenario "Use outgoing direction when unspecified"
Feature "MergeRelationshipAcceptance": Scenario "Using ON CREATE and ON MATCH"
Feature "MergeRelationshipAcceptance": Scenario "Using ON CREATE on a node"
Feature "MergeRelationshipAcceptance": Scenario "Using ON CREATE on a relationship"
Feature "MergeRelationshipAcceptance": Scenario "Using ON MATCH on a relationship"
Feature "MergeRelationshipAcceptance": Scenario "Using ON MATCH on created node"
Feature "MergeRelationshipAcceptance": Scenario "Using ON MATCH on created relationship"
Feature "MergeRelationshipAcceptance": Scenario "Using bound variables from other updating clause"
Feature "MergeRelationshipAcceptance": Scenario "Using list properties via variable"
Feature "MiscellaneousErrorAcceptance": Scenario "Failing on aggregation in ORDER BY after RETURN"
Feature "MiscellaneousErrorAcceptance": Scenario "Failing on aggregation in ORDER BY after WITH"
Feature "MiscellaneousErrorAcceptance": Scenario "Failing on aggregation in WHERE"
Feature "MiscellaneousErrorAcceptance": Scenario "Failing on incorrect unicode literal"
Feature "MiscellaneousErrorAcceptance": Scenario "Failing on merging node with null property"
Feature "MiscellaneousErrorAcceptance": Scenario "Failing on merging relationship with null property"
Feature "MiscellaneousErrorAcceptance": Scenario "Failing when UNION has different columns"
Feature "MiscellaneousErrorAcceptance": Scenario "Failing when creating with two directions"
Feature "MiscellaneousErrorAcceptance": Scenario "Failing when creating without direction"
Feature "MiscellaneousErrorAcceptance": Scenario "Failing when deleting a label"
Feature "MiscellaneousErrorAcceptance": Scenario "Failing when mixing UNION and UNION ALL"
Feature "MiscellaneousErrorAcceptance": Scenario "Failing when multiple columns have the same name"
Feature "MiscellaneousErrorAcceptance": Scenario "Failing when not aliasing expressions in WITH"
Feature "MiscellaneousErrorAcceptance": Scenario "Failing when setting a list of maps as a property"
Feature "MiscellaneousErrorAcceptance": Scenario "Failing when using RETURN * without variables in scope"
Feature "MiscellaneousErrorAcceptance": Scenario "Failing when using a list as a node"
Feature "MiscellaneousErrorAcceptance": Scenario "Failing when using a path variable that is already bound"
Feature "MiscellaneousErrorAcceptance": Scenario "Failing when using a variable length relationship as a single relationship"
Feature "MiscellaneousErrorAcceptance": Scenario "Failing when using a variable that is already bound in CREATE"
Feature "MiscellaneousErrorAcceptance": Scenario "Failing when using undefined variable in DELETE"
Feature "MiscellaneousErrorAcceptance": Scenario "Failing when using undefined variable in SET"
Feature "MiscellaneousErrorAcceptance": Scenario "Failing when using undefined variable in pattern"
Feature "NullAcceptance": Scenario "Ignore null when deleting node"
Feature "NullAcceptance": Scenario "Ignore null when deleting relationship"
Feature "NullAcceptance": Scenario "Ignore null when removing label"
Feature "NullAcceptance": Scenario "Ignore null when removing property"
Feature "NullAcceptance": Scenario "Ignore null when setting label"
Feature "NullAcceptance": Scenario "Ignore null when setting properties using an appending map"
Feature "NullAcceptance": Scenario "Ignore null when setting properties using an overriding map"
Feature "NullAcceptance": Scenario "Ignore null when setting property"
Feature "OptionalMatch": Scenario "Satisfies the open world assumption, relationships between different nodes"
Feature "OptionalMatch": Scenario "Satisfies the open world assumption, relationships between same nodes"
Feature "OptionalMatch": Scenario "Satisfies the open world assumption, single relationship"
Feature "OptionalMatchAcceptance": Scenario "Handling correlated optional matches; first does not match implies second does not match"
Feature "OptionalMatchAcceptance": Scenario "Handling optional matches between nulls"
Feature "OptionalMatchAcceptance": Scenario "Handling optional matches between optionally matched entities"
Feature "OptionalMatchAcceptance": Scenario "Longer pattern with bound nodes without matches"
Feature "OptionalMatchAcceptance": Scenario "Longer pattern with bound nodes"
Feature "OptionalMatchAcceptance": Scenario "MATCH after OPTIONAL MATCH"
Feature "OptionalMatchAcceptance": Scenario "Named paths in optional matches"
Feature "OptionalMatchAcceptance": Scenario "Named paths inside optional matches with node predicates"
Feature "OptionalMatchAcceptance": Scenario "OPTIONAL MATCH and `collect()`"
Feature "OptionalMatchAcceptance": Scenario "OPTIONAL MATCH and bound nodes"
Feature "OptionalMatchAcceptance": Scenario "OPTIONAL MATCH with labels on the optional end node"
Feature "OptionalMatchAcceptance": Scenario "Optionally matching self-loops without matches"
Feature "OptionalMatchAcceptance": Scenario "Optionally matching self-loops"
Feature "OptionalMatchAcceptance": Scenario "Respect predicates on the OPTIONAL MATCH"
Feature "OptionalMatchAcceptance": Scenario "Return null when no matches due to inline label predicate"
Feature "OptionalMatchAcceptance": Scenario "Return null when no matches due to label predicate in WHERE"
Feature "OptionalMatchAcceptance": Scenario "Returning label predicate on null node"
Feature "OptionalMatchAcceptance": Scenario "Variable length optional relationships with bound nodes"
Feature "OptionalMatchAcceptance": Scenario "Variable length optional relationships with bound nodes, no matches"
Feature "OptionalMatchAcceptance": Scenario "Variable length optional relationships with length predicates"
Feature "OptionalMatchAcceptance": Scenario "Variable length optional relationships"
Feature "OptionalMatchAcceptance": Scenario "WITH after OPTIONAL MATCH"
Feature "OrderByAcceptance": Scenario "Handle ORDER BY with LIMIT 1"
Feature "OrderByAcceptance": Scenario "Handle projections with ORDER BY - GH#4937"
Feature "OrderByAcceptance": Scenario "ORDER BY DESC should order booleans in the expected order"
Feature "OrderByAcceptance": Scenario "ORDER BY DESC should order floats in the expected order"
Feature "OrderByAcceptance": Scenario "ORDER BY DESC should order ints in the expected order"
Feature "OrderByAcceptance": Scenario "ORDER BY DESC should order strings in the expected order"
Feature "OrderByAcceptance": Scenario "ORDER BY DESC should return results in descending order"
Feature "OrderByAcceptance": Scenario "ORDER BY of a column introduced in RETURN should return salient results in ascending order"
Feature "OrderByAcceptance": Scenario "ORDER BY should order booleans in the expected order"
Feature "OrderByAcceptance": Scenario "ORDER BY should order floats in the expected order"
Feature "OrderByAcceptance": Scenario "ORDER BY should order ints in the expected order"
Feature "OrderByAcceptance": Scenario "ORDER BY should order strings in the expected order"
Feature "OrderByAcceptance": Scenario "ORDER BY should return results in ascending order"
Feature "OrderByAcceptance": Scenario "ORDER BY with LIMIT 0 should not generate errors"
Feature "OrderByAcceptance": Scenario "ORDER BY with a negative LIMIT should fail with a syntax exception"
Feature "OrderByAcceptance": Scenario "ORDER BY with negative parameter for LIMIT should not generate errors"
Feature "OrderByAcceptance": Scenario "Renaming columns before ORDER BY should return results in ascending order"
Feature "PathEquality": Scenario "Direction of traversed relationship is not significant for path equality, simple"
Feature "PatternComprehension": Scenario "Aggregating on pattern comprehension"
Feature "PatternComprehension": Scenario "Get node degree via size of pattern comprehension that specifies a relationship type"
Feature "PatternComprehension": Scenario "Get node degree via size of pattern comprehension that specifies multiple relationship types"
Feature "PatternComprehension": Scenario "Get node degree via size of pattern comprehension"
Feature "PatternComprehension": Scenario "Introducing new node variable in pattern comprehension"
Feature "PatternComprehension": Scenario "Introducing new relationship variable in pattern comprehension"
Feature "PatternComprehension": Scenario "Pattern comprehension and ORDER BY"
Feature "PatternComprehension": Scenario "Pattern comprehension inside list comprehension"
Feature "PatternComprehension": Scenario "Returning a pattern comprehension with bound nodes"
Feature "PatternComprehension": Scenario "Returning a pattern comprehension with label predicate"
Feature "PatternComprehension": Scenario "Returning a pattern comprehension"
Feature "PatternComprehension": Scenario "Using a pattern comprehension in a WITH"
Feature "PatternComprehension": Scenario "Using a variable-length pattern comprehension in a WITH"
Feature "PatternComprehension": Scenario "Using pattern comprehension in RETURN"
Feature "PatternComprehension": Scenario "Using pattern comprehension to test existence"
Feature "ProcedureCallAcceptance": Scenario "Calling the same procedure twice using the same outputs in each call"
Feature "ProcedureCallAcceptance": Scenario "In-query call to VOID procedure does not consume rows"
Feature "ProcedureCallAcceptance": Scenario "In-query call to VOID procedure that takes no arguments"
Feature "ProcedureCallAcceptance": Scenario "In-query call to procedure should fail if explicit argument is missing"
Feature "ProcedureCallAcceptance": Scenario "In-query call to procedure should fail if input type is wrong"
Feature "ProcedureCallAcceptance": Scenario "In-query call to procedure should fail if too many explicit argument are given"
Feature "ProcedureCallAcceptance": Scenario "In-query call to procedure that both takes arguments and has outputs fails if the arguments are passed implicitly and no outputs are yielded"
Feature "ProcedureCallAcceptance": Scenario "In-query call to procedure that has outputs fails if no outputs are yielded"
Feature "ProcedureCallAcceptance": Scenario "In-query call to procedure that takes arguments fails when trying to pass them implicitly"
Feature "ProcedureCallAcceptance": Scenario "In-query call to procedure that takes no arguments and yields no results"
Feature "ProcedureCallAcceptance": Scenario "In-query call to procedure that takes no arguments"
Feature "ProcedureCallAcceptance": Scenario "In-query call to procedure with argument of type FLOAT accepts value of type INTEGER"
Feature "ProcedureCallAcceptance": Scenario "In-query call to procedure with argument of type INTEGER accepts value of type FLOAT"
Feature "ProcedureCallAcceptance": Scenario "In-query call to procedure with argument of type NUMBER accepts value of type FLOAT"
Feature "ProcedureCallAcceptance": Scenario "In-query call to procedure with argument of type NUMBER accepts value of type INTEGER"
Feature "ProcedureCallAcceptance": Scenario "In-query call to procedure with explicit arguments that drops all result fields"
Feature "ProcedureCallAcceptance": Scenario "In-query call to procedure with explicit arguments"
Feature "ProcedureCallAcceptance": Scenario "In-query call to procedure with null argument"
Feature "ProcedureCallAcceptance": Scenario "In-query call to unknown procedure should fail"
Feature "ProcedureCallAcceptance": Scenario "In-query procedure call should fail if one of the argument expressions uses an aggregation function"
Feature "ProcedureCallAcceptance": Scenario "In-query procedure call should fail if shadowing an already bound variable"
Feature "ProcedureCallAcceptance": Scenario "Standalone call to VOID procedure that takes no arguments"
Feature "ProcedureCallAcceptance": Scenario "Standalone call to VOID procedure that takes no arguments, called with implicit arguments"
Feature "ProcedureCallAcceptance": Scenario "Standalone call to procedure should fail if explicit argument is missing"
Feature "ProcedureCallAcceptance": Scenario "Standalone call to procedure should fail if implicit argument is missing"
Feature "ProcedureCallAcceptance": Scenario "Standalone call to procedure should fail if input type is wrong"
Feature "ProcedureCallAcceptance": Scenario "Standalone call to procedure should fail if too many explicit argument are given"
Feature "ProcedureCallAcceptance": Scenario "Standalone call to procedure that takes no arguments and yields no results"
Feature "ProcedureCallAcceptance": Scenario "Standalone call to procedure that takes no arguments and yields no results, called with implicit arguments"
Feature "ProcedureCallAcceptance": Scenario "Standalone call to procedure that takes no arguments"
Feature "ProcedureCallAcceptance": Scenario "Standalone call to procedure with argument of type FLOAT accepts value of type INTEGER"
Feature "ProcedureCallAcceptance": Scenario "Standalone call to procedure with argument of type INTEGER accepts value of type FLOAT"
Feature "ProcedureCallAcceptance": Scenario "Standalone call to procedure with argument of type NUMBER accepts value of type FLOAT"
Feature "ProcedureCallAcceptance": Scenario "Standalone call to procedure with argument of type NUMBER accepts value of type INTEGER"
Feature "ProcedureCallAcceptance": Scenario "Standalone call to procedure with explicit arguments"
Feature "ProcedureCallAcceptance": Scenario "Standalone call to procedure with implicit arguments"
Feature "ProcedureCallAcceptance": Scenario "Standalone call to procedure with null argument"
Feature "ProcedureCallAcceptance": Scenario "Standalone call to unknown procedure should fail"
Feature "RemoveAcceptance": Scenario "Remove a missing property should be a valid operation"
Feature "RemoveAcceptance": Scenario "Remove a single label"
Feature "RemoveAcceptance": Scenario "Remove a single node property"
Feature "RemoveAcceptance": Scenario "Remove a single relationship property"
Feature "RemoveAcceptance": Scenario "Remove multiple labels"
Feature "RemoveAcceptance": Scenario "Remove multiple node properties"
Feature "RemoveAcceptance": Scenario "Remove multiple relationship properties"
Feature "RemoveAcceptance": Scenario "Should ignore nulls"
Feature "ReturnAcceptance2": Scenario "Accept valid Unicode literal"
Feature "ReturnAcceptance2": Scenario "Aggregating by a list property has a correct definition of equality"
Feature "ReturnAcceptance2": Scenario "Appending lists of same type"
Feature "ReturnAcceptance2": Scenario "Arithmetic expressions inside aggregation"
Feature "ReturnAcceptance2": Scenario "Arithmetic expressions should propagate null values"
Feature "ReturnAcceptance2": Scenario "Concatenating and returning the size of literal lists"
Feature "ReturnAcceptance2": Scenario "Concatenating lists of same type"
Feature "ReturnAcceptance2": Scenario "DISTINCT inside aggregation should work with lists in maps"
Feature "ReturnAcceptance2": Scenario "DISTINCT inside aggregation should work with nested lists in maps"
Feature "ReturnAcceptance2": Scenario "DISTINCT inside aggregation should work with nested lists of maps in maps"
Feature "ReturnAcceptance2": Scenario "DISTINCT on nullable values"
Feature "ReturnAcceptance2": Scenario "Do not fail when returning type of deleted relationships"
Feature "ReturnAcceptance2": Scenario "Fail when returning labels of deleted nodes"
Feature "ReturnAcceptance2": Scenario "Fail when returning properties of deleted nodes"
Feature "ReturnAcceptance2": Scenario "Fail when returning properties of deleted relationships"
Feature "ReturnAcceptance2": Scenario "Fail when sorting on variable removed by DISTINCT"
Feature "ReturnAcceptance2": Scenario "Handling DISTINCT with lists in maps"
Feature "ReturnAcceptance2": Scenario "Indexing into nested literal lists"
Feature "ReturnAcceptance2": Scenario "LIMIT 0 should return an empty result"
Feature "ReturnAcceptance2": Scenario "Limiting amount of rows when there are fewer left than the LIMIT argument"
Feature "ReturnAcceptance2": Scenario "Matching and disregarding output, then matching again"
Feature "ReturnAcceptance2": Scenario "Multiple aliasing and backreferencing"
Feature "ReturnAcceptance2": Scenario "Ordering with aggregation"
Feature "ReturnAcceptance2": Scenario "Projecting an arithmetic expression with aggregation"
Feature "ReturnAcceptance2": Scenario "Return all variables"
Feature "ReturnAcceptance2": Scenario "Returned columns do not change from using ORDER BY"
Feature "ReturnAcceptance2": Scenario "Returning a projected map"
Feature "ReturnAcceptance2": Scenario "Returning all variables with ordering"
Feature "ReturnAcceptance2": Scenario "Returning an expression"
Feature "ReturnAcceptance2": Scenario "Returning nested expressions based on list property"
Feature "ReturnAcceptance2": Scenario "Reusing variable names"
Feature "ReturnAcceptance2": Scenario "Setting and returning the size of a list property"
Feature "ReturnAcceptance2": Scenario "Using aliased DISTINCT expression in ORDER BY"
Feature "ReturnAcceptance2": Scenario "`sqrt()` returning float values"
Feature "ReturnAcceptance2": Scenario "`substring()` with default second argument"
Feature "ReturnAcceptanceTest": Scenario "Absolute function"
Feature "ReturnAcceptanceTest": Scenario "Allow addition"
Feature "ReturnAcceptanceTest": Scenario "Arithmetic precedence test"
Feature "ReturnAcceptanceTest": Scenario "Arithmetic precedence with parenthesis test"
Feature "ReturnAcceptanceTest": Scenario "Count star should count everything in scope"
Feature "ReturnAcceptanceTest": Scenario "Get rows in the middle by param"
Feature "ReturnAcceptanceTest": Scenario "Get rows in the middle"
Feature "ReturnAcceptanceTest": Scenario "Return collection size"
Feature "ReturnAcceptanceTest": Scenario "Sort on aggregated function"
Feature "ReturnAcceptanceTest": Scenario "Start the result from the second row by param"
Feature "ReturnAcceptanceTest": Scenario "Start the result from the second row"
Feature "ReturnAcceptanceTest": Scenario "Support ordering by a property after being distinct-ified"
Feature "ReturnAcceptanceTest": Scenario "Support sort and distinct"
Feature "SemanticErrorAcceptance": Scenario "Bad arguments for `range()`"
Feature "SemanticErrorAcceptance": Scenario "Fail for invalid Unicode hyphen in subtraction"
Feature "SemanticErrorAcceptance": Scenario "Failing for `size()` on paths"
Feature "SemanticErrorAcceptance": Scenario "Failing when a node is used as a relationship"
Feature "SemanticErrorAcceptance": Scenario "Failing when a relationship is used as a node"
Feature "SemanticErrorAcceptance": Scenario "Failing when checking existence of a non-property and non-pattern"
Feature "SemanticErrorAcceptance": Scenario "Failing when comparing to an undefined variable"
Feature "SemanticErrorAcceptance": Scenario "Failing when creating relationship with more than one type"
Feature "SemanticErrorAcceptance": Scenario "Failing when creating relationship without type"
Feature "SemanticErrorAcceptance": Scenario "Failing when deleting an integer expression"
Feature "SemanticErrorAcceptance": Scenario "Failing when float value is too large"
Feature "SemanticErrorAcceptance": Scenario "Failing when merging relationship with more than one type"
Feature "SemanticErrorAcceptance": Scenario "Failing when merging relationship without type"
Feature "SemanticErrorAcceptance": Scenario "Failing when merging relationship without type, no colon"
Feature "SemanticErrorAcceptance": Scenario "Failing when performing property access on a non-map 1"
Feature "SemanticErrorAcceptance": Scenario "Failing when performing property access on a non-map 2"
Feature "SemanticErrorAcceptance": Scenario "Failing when re-using a relationship in the same pattern"
Feature "SemanticErrorAcceptance": Scenario "Failing when returning an undefined variable"
Feature "SemanticErrorAcceptance": Scenario "Failing when using CREATE on a node that is already bound"
Feature "SemanticErrorAcceptance": Scenario "Failing when using CREATE on a relationship that is already bound"
Feature "SemanticErrorAcceptance": Scenario "Failing when using IN on a boolean literal"
Feature "SemanticErrorAcceptance": Scenario "Failing when using IN on a float literal"
Feature "SemanticErrorAcceptance": Scenario "Failing when using IN on a string literal"
Feature "SemanticErrorAcceptance": Scenario "Failing when using IN on an integer literal"
Feature "SemanticErrorAcceptance": Scenario "Failing when using MATCH after OPTIONAL MATCH"
Feature "SemanticErrorAcceptance": Scenario "Failing when using MERGE on a node that is already bound"
Feature "SemanticErrorAcceptance": Scenario "Failing when using MERGE on a relationship that is already bound"
Feature "SemanticErrorAcceptance": Scenario "Failing when using NOT on string literal"
Feature "SemanticErrorAcceptance": Scenario "Failing when using `length()` on a node"
Feature "SemanticErrorAcceptance": Scenario "Failing when using `type()` on a node"
Feature "SemanticErrorAcceptance": Scenario "Failing when using aggregation in list comprehension"
Feature "SemanticErrorAcceptance": Scenario "Failing when using floating point in LIMIT"
Feature "SemanticErrorAcceptance": Scenario "Failing when using negative value in LIMIT"
Feature "SemanticErrorAcceptance": Scenario "Failing when using negative value in SKIP"
Feature "SemanticErrorAcceptance": Scenario "Failing when using non-constants in LIMIT"
Feature "SemanticErrorAcceptance": Scenario "Failing when using non-constants in SKIP"
Feature "SemanticErrorAcceptance": Scenario "Failing when using parameter as node predicate in MATCH"
Feature "SemanticErrorAcceptance": Scenario "Failing when using parameter as node predicate in MERGE"
Feature "SemanticErrorAcceptance": Scenario "Failing when using parameter as relationship predicate in MATCH"
Feature "SemanticErrorAcceptance": Scenario "Failing when using parameter as relationship predicate in MERGE"
Feature "SemanticErrorAcceptance": Scenario "Failing when using undefined variable in ON CREATE"
Feature "SemanticErrorAcceptance": Scenario "Failing when using undefined variable in ON MATCH"
Feature "SemanticErrorAcceptance": Scenario "Failing when using variable length relationship in CREATE"
Feature "SemanticErrorAcceptance": Scenario "Failing when using variable length relationship in MERGE"
Feature "SemanticErrorAcceptance": Scenario "Handling property access on the Any type"
Feature "SetAcceptance": Scenario "Add a label to a node"
Feature "SetAcceptance": Scenario "Adding a list property"
Feature "SetAcceptance": Scenario "Concatenate elements in reverse onto a list property"
Feature "SetAcceptance": Scenario "Concatenate elements onto a list property"
Feature "SetAcceptance": Scenario "Explicit null values in a map remove old values"
Feature "SetAcceptance": Scenario "Non-existent values in a property map are removed with SET ="
Feature "SetAcceptance": Scenario "Overwrite values when using +="
Feature "SetAcceptance": Scenario "Retain old values when using +="
Feature "SetAcceptance": Scenario "Set a property by selecting the node using a simple expression"
Feature "SetAcceptance": Scenario "Set a property by selecting the relationship using a simple expression"
Feature "SetAcceptance": Scenario "Set a property to an expression"
Feature "SetAcceptance": Scenario "Set a property"
Feature "SetAcceptance": Scenario "Setting a node property to null removes the existing property"
Feature "SetAcceptance": Scenario "Setting a property to null removes the property"
Feature "SetAcceptance": Scenario "Setting a relationship property to null removes the existing property"
Feature "SkipLimitAcceptanceTest": Scenario "LIMIT with an expression that depends on variables should fail"
Feature "SkipLimitAcceptanceTest": Scenario "LIMIT with an expression that does not depend on variables"
Feature "SkipLimitAcceptanceTest": Scenario "SKIP with an expression that depends on variables should fail"
Feature "SkipLimitAcceptanceTest": Scenario "SKIP with an expression that does not depend on variables"
Feature "StartsWithAcceptance": Scenario "Combining string operators"
Feature "StartsWithAcceptance": Scenario "Finding beginning of string"
Feature "StartsWithAcceptance": Scenario "Finding end of string 1"
Feature "StartsWithAcceptance": Scenario "Finding end of string 2"
Feature "StartsWithAcceptance": Scenario "Finding exact matches"
Feature "StartsWithAcceptance": Scenario "Finding middle of string"
Feature "StartsWithAcceptance": Scenario "Finding strings containing newline"
Feature "StartsWithAcceptance": Scenario "Finding strings containing whitespace"
Feature "StartsWithAcceptance": Scenario "Finding strings ending with newline"
Feature "StartsWithAcceptance": Scenario "Finding strings ending with whitespace"
Feature "StartsWithAcceptance": Scenario "Finding strings starting with newline"
Feature "StartsWithAcceptance": Scenario "Finding strings starting with whitespace"
Feature "StartsWithAcceptance": Scenario "Finding the empty string"
Feature "StartsWithAcceptance": Scenario "Finding when the middle is known"
Feature "StartsWithAcceptance": Scenario "Handling non-string operands for CONTAINS"
Feature "StartsWithAcceptance": Scenario "Handling non-string operands for ENDS WITH"
Feature "StartsWithAcceptance": Scenario "Handling non-string operands for STARTS WITH"
Feature "StartsWithAcceptance": Scenario "NOT with CONTAINS"
Feature "StartsWithAcceptance": Scenario "No string contains null"
Feature "StartsWithAcceptance": Scenario "No string does not contain null"
Feature "StartsWithAcceptance": Scenario "No string does not end with null"
Feature "StartsWithAcceptance": Scenario "No string does not start with null"
Feature "StartsWithAcceptance": Scenario "No string ends with null"
Feature "StartsWithAcceptance": Scenario "No string starts with null"
Feature "SyntaxErrorAcceptance": Scenario "Supplying invalid hexadecimal literal 1"
Feature "SyntaxErrorAcceptance": Scenario "Supplying invalid hexadecimal literal 2"
Feature "SyntaxErrorAcceptance": Scenario "Using `rand()` in aggregations"
Feature "SyntaxErrorAcceptance": Scenario "Using a non-existent function"
Feature "TernaryLogicAcceptanceTest": Scenario "A literal null IS null"
Feature "TernaryLogicAcceptanceTest": Scenario "A literal null is not IS NOT null"
Feature "TernaryLogicAcceptanceTest": Scenario "It is unknown - i.e. null - if a null is equal to a null"
Feature "TernaryLogicAcceptanceTest": Scenario "It is unknown - i.e. null - if a null is not equal to a null"
Feature "TernaryLogicAcceptanceTest": Scenario "The inverse of a null is a null"
Feature "TernaryLogicAcceptanceTest": Scenario "Using null in AND #1"
Feature "TernaryLogicAcceptanceTest": Scenario "Using null in AND #2"
Feature "TernaryLogicAcceptanceTest": Scenario "Using null in AND #3"
Feature "TernaryLogicAcceptanceTest": Scenario "Using null in AND #4"
Feature "TernaryLogicAcceptanceTest": Scenario "Using null in AND #5"
Feature "TernaryLogicAcceptanceTest": Scenario "Using null in IN #1"
Feature "TernaryLogicAcceptanceTest": Scenario "Using null in IN #2"
Feature "TernaryLogicAcceptanceTest": Scenario "Using null in IN #3"
Feature "TernaryLogicAcceptanceTest": Scenario "Using null in IN #4"
Feature "TernaryLogicAcceptanceTest": Scenario "Using null in IN #5"
Feature "TernaryLogicAcceptanceTest": Scenario "Using null in IN #6"
Feature "TernaryLogicAcceptanceTest": Scenario "Using null in IN #7"
Feature "TernaryLogicAcceptanceTest": Scenario "Using null in OR #1"
Feature "TernaryLogicAcceptanceTest": Scenario "Using null in OR #2"
Feature "TernaryLogicAcceptanceTest": Scenario "Using null in OR #3"
Feature "TernaryLogicAcceptanceTest": Scenario "Using null in OR #4"
Feature "TernaryLogicAcceptanceTest": Scenario "Using null in OR #5"
Feature "TernaryLogicAcceptanceTest": Scenario "Using null in XOR #1"
Feature "TernaryLogicAcceptanceTest": Scenario "Using null in XOR #2"
Feature "TernaryLogicAcceptanceTest": Scenario "Using null in XOR #3"
Feature "TernaryLogicAcceptanceTest": Scenario "Using null in XOR #4"
Feature "TernaryLogicAcceptanceTest": Scenario "Using null in XOR #5"
Feature "TriadicSelection": Scenario "Handling triadic friend of a friend that is a friend with different labels"
Feature "TriadicSelection": Scenario "Handling triadic friend of a friend that is a friend with different relationship type"
Feature "TriadicSelection": Scenario "Handling triadic friend of a friend that is a friend with explicit subset of relationship type"
Feature "TriadicSelection": Scenario "Handling triadic friend of a friend that is a friend with implicit subset of labels"
Feature "TriadicSelection": Scenario "Handling triadic friend of a friend that is a friend with implicit subset of relationship type"
Feature "TriadicSelection": Scenario "Handling triadic friend of a friend that is a friend with implicit superset of labels"
Feature "TriadicSelection": Scenario "Handling triadic friend of a friend that is a friend with same labels"
Feature "TriadicSelection": Scenario "Handling triadic friend of a friend that is a friend with superset of relationship type"
Feature "TriadicSelection": Scenario "Handling triadic friend of a friend that is a friend"
Feature "TriadicSelection": Scenario "Handling triadic friend of a friend that is not a friend with different labels"
Feature "TriadicSelection": Scenario "Handling triadic friend of a friend that is not a friend with different relationship type"
Feature "TriadicSelection": Scenario "Handling triadic friend of a friend that is not a friend with explicit subset of relationship type"
Feature "TriadicSelection": Scenario "Handling triadic friend of a friend that is not a friend with implicit subset of labels"
Feature "TriadicSelection": Scenario "Handling triadic friend of a friend that is not a friend with implicit subset of relationship type"
Feature "TriadicSelection": Scenario "Handling triadic friend of a friend that is not a friend with implicit superset of labels"
Feature "TriadicSelection": Scenario "Handling triadic friend of a friend that is not a friend with same labels"
Feature "TriadicSelection": Scenario "Handling triadic friend of a friend that is not a friend with superset of relationship type"
Feature "TriadicSelection": Scenario "Handling triadic friend of a friend that is not a friend"
Feature "TypeConversionFunctions": Scenario "`toBoolean()` on booleans"
Feature "TypeConversionFunctions": Scenario "`toBoolean()` on invalid strings"
Feature "TypeConversionFunctions": Scenario "`toBoolean()` on valid literal string"
Feature "TypeConversionFunctions": Scenario "`toBoolean()` on variables with valid string values"
Feature "TypeConversionFunctions": Scenario "`toFloat()` handling Any type"
Feature "TypeConversionFunctions": Scenario "`toFloat()` on a list of strings"
Feature "TypeConversionFunctions": Scenario "`toFloat()` on mixed number types"
Feature "TypeConversionFunctions": Scenario "`toFloat()` returning null on non-numerical string"
Feature "TypeConversionFunctions": Scenario "`toFloat()`"
Feature "TypeConversionFunctions": Scenario "`toInteger()` handling Any type"
Feature "TypeConversionFunctions": Scenario "`toInteger()` handling mixed number types"
Feature "TypeConversionFunctions": Scenario "`toInteger()` on a complex-typed expression"
Feature "TypeConversionFunctions": Scenario "`toInteger()` on a list of strings"
Feature "TypeConversionFunctions": Scenario "`toInteger()` on float"
Feature "TypeConversionFunctions": Scenario "`toInteger()` returning null on non-numerical string"
Feature "TypeConversionFunctions": Scenario "`toInteger()`"
Feature "TypeConversionFunctions": Scenario "`toString()` handling boolean literal"
Feature "TypeConversionFunctions": Scenario "`toString()` handling boolean properties"
Feature "TypeConversionFunctions": Scenario "`toString()` handling inlined boolean"
Feature "TypeConversionFunctions": Scenario "`toString()` on a list of integers"
Feature "TypeConversionFunctions": Scenario "`toString()` should accept potentially correct types 1"
Feature "TypeConversionFunctions": Scenario "`toString()` should accept potentially correct types 2"
Feature "TypeConversionFunctions": Scenario "`toString()` should work on Any type"
Feature "TypeConversionFunctions": Scenario "`toString()`"
Feature "UnionAcceptance": Scenario "Should be able to create text output from union queries"
Feature "UnionAcceptance": Scenario "Three elements, two unique, distinct"
Feature "UnionAcceptance": Scenario "Three elements, two unique, not distinct"
Feature "UnionAcceptance": Scenario "Two elements, both unique, distinct"
Feature "UnionAcceptance": Scenario "Two elements, both unique, not distinct"
Feature "UnwindAcceptance": Scenario "Creating nodes from an unwound parameter list"
Feature "UnwindAcceptance": Scenario "Double unwinding a list of lists"
Feature "UnwindAcceptance": Scenario "Multiple unwinds after each other"
Feature "UnwindAcceptance": Scenario "Unwind does not prune context"
Feature "UnwindAcceptance": Scenario "Unwind does not remove variables from scope"
Feature "UnwindAcceptance": Scenario "Unwind with merge"
Feature "UnwindAcceptance": Scenario "Unwinding a collected expression"
Feature "UnwindAcceptance": Scenario "Unwinding a collected unwound expression"
Feature "UnwindAcceptance": Scenario "Unwinding a concatenation of lists"
Feature "UnwindAcceptance": Scenario "Unwinding a list"
Feature "UnwindAcceptance": Scenario "Unwinding a range"
Feature "UnwindAcceptance": Scenario "Unwinding list with duplicates"
Feature "UnwindAcceptance": Scenario "Unwinding null"
Feature "UnwindAcceptance": Scenario "Unwinding the empty list"
Feature "VarLengthAcceptance": Scenario "Fail on negative bound"
Feature "VarLengthAcceptance": Scenario "Fail when asterisk operator is missing"
Feature "VarLengthAcceptance": Scenario "Handling a variable length relationship and a standard relationship in chain, longer 1"
Feature "VarLengthAcceptance": Scenario "Handling a variable length relationship and a standard relationship in chain, longer 2"
Feature "VarLengthAcceptance": Scenario "Handling a variable length relationship and a standard relationship in chain, longer 3"
Feature "VarLengthAcceptance": Scenario "Handling a variable length relationship and a standard relationship in chain, single length 1"
Feature "VarLengthAcceptance": Scenario "Handling a variable length relationship and a standard relationship in chain, single length 2"
Feature "VarLengthAcceptance": Scenario "Handling a variable length relationship and a standard relationship in chain, zero length 1"
Feature "VarLengthAcceptance": Scenario "Handling a variable length relationship and a standard relationship in chain, zero length 2"
Feature "VarLengthAcceptance": Scenario "Handling explicitly unbounded variable length match"
Feature "VarLengthAcceptance": Scenario "Handling lower bounded variable length match 1"
Feature "VarLengthAcceptance": Scenario "Handling lower bounded variable length match 2"
Feature "VarLengthAcceptance": Scenario "Handling lower bounded variable length match 3"
Feature "VarLengthAcceptance": Scenario "Handling mixed relationship patterns 1"
Feature "VarLengthAcceptance": Scenario "Handling mixed relationship patterns 2"
Feature "VarLengthAcceptance": Scenario "Handling mixed relationship patterns and directions 1"
Feature "VarLengthAcceptance": Scenario "Handling mixed relationship patterns and directions 2"
Feature "VarLengthAcceptance": Scenario "Handling single bounded variable length match 1"
Feature "VarLengthAcceptance": Scenario "Handling single bounded variable length match 2"
Feature "VarLengthAcceptance": Scenario "Handling single bounded variable length match 3"
Feature "VarLengthAcceptance": Scenario "Handling symmetrically bounded variable length match, bounds are one"
Feature "VarLengthAcceptance": Scenario "Handling symmetrically bounded variable length match, bounds are two"
Feature "VarLengthAcceptance": Scenario "Handling symmetrically bounded variable length match, bounds are zero"
Feature "VarLengthAcceptance": Scenario "Handling unbounded variable length match"
Feature "VarLengthAcceptance": Scenario "Handling upper and lower bounded variable length match 1"
Feature "VarLengthAcceptance": Scenario "Handling upper and lower bounded variable length match 2"
Feature "VarLengthAcceptance": Scenario "Handling upper and lower bounded variable length match, empty interval 1"
Feature "VarLengthAcceptance": Scenario "Handling upper and lower bounded variable length match, empty interval 2"
Feature "VarLengthAcceptance": Scenario "Handling upper bounded variable length match 1"
Feature "VarLengthAcceptance": Scenario "Handling upper bounded variable length match 2"
Feature "VarLengthAcceptance": Scenario "Handling upper bounded variable length match, empty interval"
Feature "VarLengthAcceptance2": Scenario "Handling relationships that are already bound in variable length paths"
Feature "WithAcceptance": Scenario "A simple pattern with one bound endpoint"
Feature "WithAcceptance": Scenario "Aliasing"
Feature "WithAcceptance": Scenario "Connected components succeeding WITH"
Feature "WithAcceptance": Scenario "Handle dependencies across WITH with SKIP"
Feature "WithAcceptance": Scenario "Handle dependencies across WITH"
Feature "WithAcceptance": Scenario "Multiple WITHs using a predicate and aggregation"
Feature "WithAcceptance": Scenario "Nested maps"
Feature "WithAcceptance": Scenario "No dependencies between the query parts"
Feature "WithAcceptance": Scenario "Null handling"
Feature "WithAcceptance": Scenario "ORDER BY a DISTINCT column"
Feature "WithAcceptance": Scenario "ORDER BY and LIMIT can be used"
Feature "WithAcceptance": Scenario "ORDER BY on an aggregating key"
Feature "WithAcceptance": Scenario "Single WITH using a predicate and aggregation"
Feature "WithAcceptance": Scenario "WHERE after WITH can filter on top of an aggregation"
Feature "WithAcceptance": Scenario "WHERE on a DISTINCT column"